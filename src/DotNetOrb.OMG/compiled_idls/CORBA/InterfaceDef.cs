/**
 * Generated by DotNetORb.IdlCompiler V 1.0.0.0
 * Timestamp: 25/02/2024 9:49:27
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using CORBA;


namespace CORBA
{
	public abstract partial class InterfaceDef : CORBA.Object, CORBA.IInterfaceDef
	{
		[RepositoryID("IDL:CORBA/InterfaceDef/FullInterfaceDescription:1.0")]
		[Helper(typeof(FullInterfaceDescriptionHelper))]
		public partial class FullInterfaceDescription: CORBA.IIDLEntity, IEquatable<CORBA.InterfaceDef.FullInterfaceDescription>
		{
			[IdlName("FullInterfaceDescription")]
			[WideChar(false)]
			public string Name { get; set; }
			[IdlName("FullInterfaceDescription")]
			[WideChar(false)]
			public string Id { get; set; }
			[IdlName("FullInterfaceDescription")]
			[WideChar(false)]
			public string DefinedIn { get; set; }
			[IdlName("FullInterfaceDescription")]
			[WideChar(false)]
			public string Version { get; set; }
			[IdlName("FullInterfaceDescription")]
			public CORBA.OperationDescription[] Operations { get; set; }
			[IdlName("FullInterfaceDescription")]
			public CORBA.AttributeDescription[] Attributes { get; set; }
			[IdlName("FullInterfaceDescription")]
			public string[] BaseInterfaces { get; set; }
			[IdlName("FullInterfaceDescription")]
			public CORBA.TypeCode Type { get; set; }
			[IdlName("FullInterfaceDescription")]
			public bool IsAbstract { get; set; }

			public FullInterfaceDescription()
			{
			}

			public FullInterfaceDescription(FullInterfaceDescription other)
			{
				Name = other.Name;
				Id = other.Id;
				DefinedIn = other.DefinedIn;
				Version = other.Version;
				Operations = other.Operations;
				Attributes = other.Attributes;
				BaseInterfaces = other.BaseInterfaces;
				Type = other.Type;
				IsAbstract = other.IsAbstract;
			}

			public FullInterfaceDescription(string name, string id, string definedIn, string version, CORBA.OperationDescription[] operations, CORBA.AttributeDescription[] attributes, string[] baseInterfaces, CORBA.TypeCode type, bool isAbstract)
			{
				this.Name = name;
				this.Id = id;
				this.DefinedIn = definedIn;
				this.Version = version;
				this.Operations = operations;
				this.Attributes = attributes;
				this.BaseInterfaces = baseInterfaces;
				this.Type = type;
				this.IsAbstract = isAbstract;
			}

			public bool Equals(CORBA.InterfaceDef.FullInterfaceDescription? other)
			{
				if (other == null) return false;
				if (!Name.Equals(other.Name)) return false;
				if (!Id.Equals(other.Id)) return false;
				if (!DefinedIn.Equals(other.DefinedIn)) return false;
				if (!Version.Equals(other.Version)) return false;
				if (!Operations.SequenceEqual(other.Operations)) return false;
				if (!Attributes.SequenceEqual(other.Attributes)) return false;
				if (!BaseInterfaces.SequenceEqual(other.BaseInterfaces)) return false;
				if (!Type.Equals(other.Type)) return false;
				if (!IsAbstract.Equals(other.IsAbstract)) return false;
				return true;
			}
		}

		public static class FullInterfaceDescriptionHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(FullInterfaceDescriptionHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateStructTc(CORBA.InterfaceDef.FullInterfaceDescriptionHelper.Id(), "FullInterfaceDescription", new CORBA.StructMember[] {new CORBA.StructMember("name", CORBA.ORB.Init().CreateStringTc(0), null), new CORBA.StructMember("id", CORBA.ORB.Init().CreateStringTc(0), null), new CORBA.StructMember("defined_in", CORBA.ORB.Init().CreateStringTc(0), null), new CORBA.StructMember("version", CORBA.ORB.Init().CreateStringTc(0), null), new CORBA.StructMember("operations", CORBA.ORB.Init().CreateSequenceTc(0, CORBA.OperationDescriptionHelper.Type()), null), new CORBA.StructMember("attributes", CORBA.ORB.Init().CreateSequenceTc(0, CORBA.AttributeDescriptionHelper.Type()), null), new CORBA.StructMember("base_interfaces", CORBA.ORB.Init().CreateSequenceTc(0, CORBA.ORB.Init().CreateStringTc(0)), null), new CORBA.StructMember("type", CORBA.ORB.Init().GetPrimitiveTc((CORBA.TCKind) 12), null), new CORBA.StructMember("is_abstract", CORBA.ORB.Init().GetPrimitiveTc((CORBA.TCKind) 8), null), });
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, CORBA.InterfaceDef.FullInterfaceDescription s)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), s);
			}

			public static CORBA.InterfaceDef.FullInterfaceDescription Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:CORBA/InterfaceDef/FullInterfaceDescription:1.0";
			}

			public static CORBA.InterfaceDef.FullInterfaceDescription Read(CORBA.IInputStream inputStream)
			{
				var result = new CORBA.InterfaceDef.FullInterfaceDescription();
				result.Name = inputStream.ReadString();
				result.Id = inputStream.ReadString();
				result.DefinedIn = inputStream.ReadString();
				result.Version = inputStream.ReadString();
				{
					var _capacity0 = inputStream.ReadLong();
					if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
					{
						throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
					}
					result.Operations = new CORBA.OperationDescription[_capacity0];
					for (int i0 = 0; i0 < _capacity0; i0++)
					{
						CORBA.OperationDescription _item0;
						_item0 = CORBA.OperationDescriptionHelper.Read(inputStream);
						result.Operations[i0] = _item0;
					}
				}
				{
					var _capacity0 = inputStream.ReadLong();
					if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
					{
						throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
					}
					result.Attributes = new CORBA.AttributeDescription[_capacity0];
					for (int i0 = 0; i0 < _capacity0; i0++)
					{
						CORBA.AttributeDescription _item0;
						_item0 = CORBA.AttributeDescriptionHelper.Read(inputStream);
						result.Attributes[i0] = _item0;
					}
				}
				{
					var _capacity0 = inputStream.ReadLong();
					if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
					{
						throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
					}
					result.BaseInterfaces = new string[_capacity0];
					for (int i0 = 0; i0 < _capacity0; i0++)
					{
						string _item0;
						_item0 = inputStream.ReadString();
						result.BaseInterfaces[i0] = _item0;
					}
				}
				result.Type = inputStream.ReadTypeCode();
				result.IsAbstract = inputStream.ReadBoolean();
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, CORBA.InterfaceDef.FullInterfaceDescription s)
			{
				outputStream.WriteString(s.Name);
				outputStream.WriteString(s.Id);
				outputStream.WriteString(s.DefinedIn);
				outputStream.WriteString(s.Version);
				{
					outputStream.WriteLong(s.Operations.Length);
					for (int i0 = 0; i0 < s.Operations.Length; i0++)
					{
						CORBA.OperationDescriptionHelper.Write(outputStream, s.Operations[i0]);
					}
				}
				{
					outputStream.WriteLong(s.Attributes.Length);
					for (int i0 = 0; i0 < s.Attributes.Length; i0++)
					{
						CORBA.AttributeDescriptionHelper.Write(outputStream, s.Attributes[i0]);
					}
				}
				{
					outputStream.WriteLong(s.BaseInterfaces.Length);
					for (int i0 = 0; i0 < s.BaseInterfaces.Length; i0++)
					{
						outputStream.WriteString(s.BaseInterfaces[i0]);
					}
				}
				outputStream.WriteTypeCode(s.Type);
				outputStream.WriteBoolean(s.IsAbstract);
			}

		}
		[IdlName("def_kind")]
		public abstract CORBA.DefinitionKind DefKind 
		{
			get;
		}
		[IdlName("destroy")]
		public abstract void Destroy();
		[IdlName("lookup")]
		public abstract CORBA.IContained Lookup([WideChar(false)] string searchName);
		[IdlName("contents")]
		public abstract CORBA.IContained[] Contents(CORBA.DefinitionKind limitType, bool excludeInherited);
		[IdlName("lookup_name")]
		public abstract CORBA.IContained[] LookupName([WideChar(false)] string searchName, int levelsToSearch, CORBA.DefinitionKind limitType, bool excludeInherited);
		[IdlName("describe_contents")]
		public abstract CORBA.Container.Description[] DescribeContents(CORBA.DefinitionKind limitType, bool excludeInherited, int maxReturnedObjs);
		[IdlName("create_module")]
		public abstract CORBA.IModuleDef CreateModule([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version);
		[IdlName("create_constant")]
		public abstract CORBA.IConstantDef CreateConstant([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType type, CORBA.Any value);
		[IdlName("create_struct")]
		public abstract CORBA.IStructDef CreateStruct([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.StructMember[] members);
		[IdlName("create_union")]
		public abstract CORBA.IUnionDef CreateUnion([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType discriminatorType, CORBA.UnionMember[] members);
		[IdlName("create_enum")]
		public abstract CORBA.IEnumDef CreateEnum([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, string[] members);
		[IdlName("create_alias")]
		public abstract CORBA.IAliasDef CreateAlias([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType originalType);
		[IdlName("create_interface")]
		public abstract CORBA.IInterfaceDef CreateInterface([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IInterfaceDef[] baseInterfaces, bool isAbstract);
		[IdlName("create_value")]
		public abstract CORBA.IValueDef CreateValue([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, bool isCustom, bool isAbstract, CORBA.IValueDef baseValue, bool isTruncatable, CORBA.IValueDef[] abstractBaseValues, CORBA.IInterfaceDef[] supportedInterfaces, CORBA.Initializer[] initializers);
		[IdlName("create_value_box")]
		public abstract CORBA.IValueBoxDef CreateValueBox([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType originalTypeDef);
		[IdlName("create_exception")]
		public abstract CORBA.IExceptionDef CreateException([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.StructMember[] members);
		[IdlName("create_native")]
		public abstract CORBA.INativeDef CreateNative([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version);
		[IdlName("create_abstract_interface")]
		public abstract CORBA.IAbstractInterfaceDef CreateAbstractInterface([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IAbstractInterfaceDef[] baseInterfaces);
		[IdlName("create_local_interface")]
		public abstract CORBA.ILocalInterfaceDef CreateLocalInterface([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IInterfaceDef[] baseInterfaces);
		[IdlName("create_ext_value")]
		public abstract CORBA.IExtValueDef CreateExtValue([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, bool isCustom, bool isAbstract, CORBA.IValueDef baseValue, bool isTruncatable, CORBA.IValueDef[] abstractBaseValues, CORBA.IInterfaceDef[] supportedInterfaces, CORBA.ExtInitializer[] initializers);
		[IdlName("id")]
		[WideChar(false)]
		public abstract string Id 
		{
			get;

			set;
		}
		[IdlName("name")]
		[WideChar(false)]
		public abstract string Name 
		{
			get;

			set;
		}
		[IdlName("version")]
		[WideChar(false)]
		public abstract string Version 
		{
			get;

			set;
		}
		[IdlName("defined_in")]
		public abstract CORBA.IContainer DefinedIn 
		{
			get;
		}
		[IdlName("absolute_name")]
		[WideChar(false)]
		public abstract string AbsoluteName 
		{
			get;
		}
		[IdlName("containing_repository")]
		public abstract CORBA.IRepository ContainingRepository 
		{
			get;
		}
		[IdlName("describe")]
		public abstract CORBA.Contained.Description Describe();
		[IdlName("move")]
		public abstract void Move(CORBA.IContainer newContainer, [WideChar(false)] string newName, [WideChar(false)] string newVersion);
		[IdlName("type")]
		public abstract CORBA.TypeCode Type 
		{
			get;
		}
		[IdlName("base_interfaces")]
		public abstract CORBA.IInterfaceDef[] BaseInterfaces 
		{
			get;

			set;
		}
		[IdlName("is_abstract")]
		public abstract bool IsAbstract 
		{
			get;

			set;
		}
		[IdlName("is_a")]
		public abstract bool IsA([WideChar(false)] string interfaceId);
		[IdlName("describe_interface")]
		public abstract CORBA.InterfaceDef.FullInterfaceDescription DescribeInterface();
		[IdlName("create_attribute")]
		public abstract CORBA.IAttributeDef CreateAttribute([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType type, CORBA.AttributeMode mode);
		[IdlName("create_operation")]
		public abstract CORBA.IOperationDef CreateOperation([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType result, CORBA.OperationMode mode, CORBA.ParameterDescription[] @params, CORBA.IExceptionDef[] exceptions, string[] contexts);
	}
}

