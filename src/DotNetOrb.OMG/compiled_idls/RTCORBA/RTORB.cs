/**
 * Generated by DotNetORb.IdlCompiler V 1.0.0.0
 * Timestamp: 25/02/2024 9:49:28
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using CORBA;


namespace RTCORBA
{
	public abstract partial class RTORB : CORBA.Object, RTCORBA.IRTORB
	{
		[IdlName("InvalidThreadpool")]
		[RepositoryID("IDL:RTCORBA/RTORB/InvalidThreadpool:1.0")]
		[Helper(typeof(InvalidThreadpoolHelper))]
		public partial class InvalidThreadpool: CORBA.UserException, CORBA.IIDLEntity, IEquatable<RTCORBA.RTORB.InvalidThreadpool>
		{
			public InvalidThreadpool()
			{
			}

			public InvalidThreadpool(string _msg): base(_msg)
			{
			}

			public InvalidThreadpool(InvalidThreadpool other)
			{
			}

			public bool Equals(RTCORBA.RTORB.InvalidThreadpool? other)
			{
				if (other == null) return false;
				return true;
			}
		}

		public static class InvalidThreadpoolHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(InvalidThreadpoolHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateExceptionTc(RTCORBA.RTORB.InvalidThreadpoolHelper.Id(), "InvalidThreadpool", new CORBA.StructMember[] {});
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, RTCORBA.RTORB.InvalidThreadpool e)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), e);
			}

			public static RTCORBA.RTORB.InvalidThreadpool Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:RTCORBA/RTORB/InvalidThreadpool:1.0";
			}

			public static RTCORBA.RTORB.InvalidThreadpool Read(CORBA.IInputStream inputStream)
			{
				var id = inputStream.ReadString();
				if (!id.Equals(Id()))
				{
					throw new CORBA.Marshal("Wrong id: " + id);
				}
				var result = new RTCORBA.RTORB.InvalidThreadpool();
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, RTCORBA.RTORB.InvalidThreadpool e)
			{
				outputStream.WriteString(Id());
			}

		}
		[IdlName("create_mutex")]
		public abstract RTCORBA.IMutex CreateMutex();
		[IdlName("destroy_mutex")]
		public abstract void DestroyMutex(RTCORBA.IMutex theMutex);
		[IdlName("create_threadpool")]
		public abstract uint CreateThreadpool(uint stacksize, uint staticThreads, uint dynamicThreads, short defaultPriority, bool allowRequestBuffering, uint maxBufferedRequests, uint maxRequestBufferSize);
		[IdlName("create_threadpool_with_lanes")]
		public abstract uint CreateThreadpoolWithLanes(uint stacksize, RTCORBA.ThreadpoolLane[] lanes, bool allowBorrowing, bool allowRequestBuffering, uint maxBufferedRequests, uint maxRequestBufferSize);
		[IdlName("destroy_threadpool")]
		[ThrowsIdlException(typeof(RTCORBA.RTORB.InvalidThreadpool))]
		public abstract void DestroyThreadpool(uint threadpool);
		[IdlName("create_priority_model_policy")]
		public abstract RTCORBA.IPriorityModelPolicy CreatePriorityModelPolicy(RTCORBA.PriorityModel priorityModel, short serverPriority);
		[IdlName("create_threadpool_policy")]
		public abstract RTCORBA.IThreadpoolPolicy CreateThreadpoolPolicy(uint threadpool);
		[IdlName("create_priority_banded_connection_policy")]
		public abstract RTCORBA.IPriorityBandedConnectionPolicy CreatePriorityBandedConnectionPolicy(RTCORBA.PriorityBand[] priorityBands);
		[IdlName("create_server_protocol_policy")]
		public abstract RTCORBA.IServerProtocolPolicy CreateServerProtocolPolicy(RTCORBA.Protocol[] protocols);
		[IdlName("create_client_protocol_policy")]
		public abstract RTCORBA.IClientProtocolPolicy CreateClientProtocolPolicy(RTCORBA.Protocol[] protocols);
		[IdlName("create_private_connection_policy")]
		public abstract RTCORBA.IPrivateConnectionPolicy CreatePrivateConnectionPolicy();
		[IdlName("create_tcp_protocol_properties")]
		public abstract RTCORBA.ITCPProtocolProperties CreateTcpProtocolProperties(int sendBufferSize, int recvBufferSize, bool keepAlive, bool dontRoute, bool noDelay);
	}
}

