/**
 * Generated by DotNetORb.IdlCompiler V 1.0.0.0
 * Timestamp: 25/02/2024 9:49:28
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using CORBA;


namespace IOP
{
	public abstract partial class Codec : CORBA.Object, IOP.ICodec
	{
		[IdlName("InvalidTypeForEncoding")]
		[RepositoryID("IDL:IOP/Codec/InvalidTypeForEncoding:1.0")]
		[Helper(typeof(InvalidTypeForEncodingHelper))]
		public partial class InvalidTypeForEncoding: CORBA.UserException, CORBA.IIDLEntity, IEquatable<IOP.Codec.InvalidTypeForEncoding>
		{
			public InvalidTypeForEncoding()
			{
			}

			public InvalidTypeForEncoding(string _msg): base(_msg)
			{
			}

			public InvalidTypeForEncoding(InvalidTypeForEncoding other)
			{
			}

			public bool Equals(IOP.Codec.InvalidTypeForEncoding? other)
			{
				if (other == null) return false;
				return true;
			}
		}

		public static class InvalidTypeForEncodingHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(InvalidTypeForEncodingHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateExceptionTc(IOP.Codec.InvalidTypeForEncodingHelper.Id(), "InvalidTypeForEncoding", new CORBA.StructMember[] {});
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, IOP.Codec.InvalidTypeForEncoding e)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), e);
			}

			public static IOP.Codec.InvalidTypeForEncoding Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:IOP/Codec/InvalidTypeForEncoding:1.0";
			}

			public static IOP.Codec.InvalidTypeForEncoding Read(CORBA.IInputStream inputStream)
			{
				var id = inputStream.ReadString();
				if (!id.Equals(Id()))
				{
					throw new CORBA.Marshal("Wrong id: " + id);
				}
				var result = new IOP.Codec.InvalidTypeForEncoding();
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, IOP.Codec.InvalidTypeForEncoding e)
			{
				outputStream.WriteString(Id());
			}

		}
		[IdlName("FormatMismatch")]
		[RepositoryID("IDL:IOP/Codec/FormatMismatch:1.0")]
		[Helper(typeof(FormatMismatchHelper))]
		public partial class FormatMismatch: CORBA.UserException, CORBA.IIDLEntity, IEquatable<IOP.Codec.FormatMismatch>
		{
			public FormatMismatch()
			{
			}

			public FormatMismatch(string _msg): base(_msg)
			{
			}

			public FormatMismatch(FormatMismatch other)
			{
			}

			public bool Equals(IOP.Codec.FormatMismatch? other)
			{
				if (other == null) return false;
				return true;
			}
		}

		public static class FormatMismatchHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(FormatMismatchHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateExceptionTc(IOP.Codec.FormatMismatchHelper.Id(), "FormatMismatch", new CORBA.StructMember[] {});
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, IOP.Codec.FormatMismatch e)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), e);
			}

			public static IOP.Codec.FormatMismatch Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:IOP/Codec/FormatMismatch:1.0";
			}

			public static IOP.Codec.FormatMismatch Read(CORBA.IInputStream inputStream)
			{
				var id = inputStream.ReadString();
				if (!id.Equals(Id()))
				{
					throw new CORBA.Marshal("Wrong id: " + id);
				}
				var result = new IOP.Codec.FormatMismatch();
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, IOP.Codec.FormatMismatch e)
			{
				outputStream.WriteString(Id());
			}

		}
		[IdlName("TypeMismatch")]
		[RepositoryID("IDL:IOP/Codec/TypeMismatch:1.0")]
		[Helper(typeof(TypeMismatchHelper))]
		public partial class TypeMismatch: CORBA.UserException, CORBA.IIDLEntity, IEquatable<IOP.Codec.TypeMismatch>
		{
			public TypeMismatch()
			{
			}

			public TypeMismatch(string _msg): base(_msg)
			{
			}

			public TypeMismatch(TypeMismatch other)
			{
			}

			public bool Equals(IOP.Codec.TypeMismatch? other)
			{
				if (other == null) return false;
				return true;
			}
		}

		public static class TypeMismatchHelper
		{
			private static volatile CORBA.TypeCode type;

			public static CORBA.TypeCode Type()
			{
				if (type == null)
				{
					lock (typeof(TypeMismatchHelper))
					{
						if (type == null)
						{
							type = CORBA.ORB.Init().CreateExceptionTc(IOP.Codec.TypeMismatchHelper.Id(), "TypeMismatch", new CORBA.StructMember[] {});
						}
					}
				}
				return type;
			}

			public static void Insert(CORBA.Any any, IOP.Codec.TypeMismatch e)
			{
				any.Type = Type();
				Write(any.CreateOutputStream(), e);
			}

			public static IOP.Codec.TypeMismatch Extract(CORBA.Any any)
			{
				var inputStream = any.CreateInputStream();
				try
				{
					return Read(inputStream);
				}
				finally
				{
					inputStream.Close();
				}
			}

			public static string Id()
			{
				return "IDL:IOP/Codec/TypeMismatch:1.0";
			}

			public static IOP.Codec.TypeMismatch Read(CORBA.IInputStream inputStream)
			{
				var id = inputStream.ReadString();
				if (!id.Equals(Id()))
				{
					throw new CORBA.Marshal("Wrong id: " + id);
				}
				var result = new IOP.Codec.TypeMismatch();
				return result;
			}

			public static void Write(CORBA.IOutputStream outputStream, IOP.Codec.TypeMismatch e)
			{
				outputStream.WriteString(Id());
			}

		}
		[IdlName("encode")]
		[ThrowsIdlException(typeof(IOP.Codec.InvalidTypeForEncoding))]
		public abstract byte[] Encode(CORBA.Any data);
		[IdlName("decode")]
		[ThrowsIdlException(typeof(IOP.Codec.FormatMismatch))]
		public abstract CORBA.Any Decode(byte[] data);
		[IdlName("encode_value")]
		[ThrowsIdlException(typeof(IOP.Codec.InvalidTypeForEncoding))]
		public abstract byte[] EncodeValue(CORBA.Any data);
		[IdlName("decode_value")]
		[ThrowsIdlException(typeof(IOP.Codec.FormatMismatch))]
		[ThrowsIdlException(typeof(IOP.Codec.TypeMismatch))]
		public abstract CORBA.Any DecodeValue(byte[] data, CORBA.TypeCode tc);
	}
}

