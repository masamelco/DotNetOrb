/**
 * Generated by DotNetORb.IdlCompiler V 1.0.0.0
 * Timestamp: 25/02/2024 9:49:27
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using CORBA;


namespace CORBA
{

	public abstract class RepositoryPOA: PortableServer.Servant, CORBA.IInvokeHandler, IRepositoryOperations
	{
		static private Dictionary<string,int> _opsDict = new Dictionary<string,int>();
		static RepositoryPOA()
		{
			_opsDict.Add("_get_def_kind", 0);
			_opsDict.Add("destroy", 1);
			_opsDict.Add("lookup", 2);
			_opsDict.Add("contents", 3);
			_opsDict.Add("lookup_name", 4);
			_opsDict.Add("describe_contents", 5);
			_opsDict.Add("create_module", 6);
			_opsDict.Add("create_constant", 7);
			_opsDict.Add("create_struct", 8);
			_opsDict.Add("create_union", 9);
			_opsDict.Add("create_enum", 10);
			_opsDict.Add("create_alias", 11);
			_opsDict.Add("create_interface", 12);
			_opsDict.Add("create_value", 13);
			_opsDict.Add("create_value_box", 14);
			_opsDict.Add("create_exception", 15);
			_opsDict.Add("create_native", 16);
			_opsDict.Add("create_abstract_interface", 17);
			_opsDict.Add("create_local_interface", 18);
			_opsDict.Add("create_ext_value", 19);
			_opsDict.Add("lookup_id", 20);
			_opsDict.Add("get_canonical_typecode", 21);
			_opsDict.Add("get_primitive", 22);
			_opsDict.Add("create_string", 23);
			_opsDict.Add("create_wstring", 24);
			_opsDict.Add("create_sequence", 25);
			_opsDict.Add("create_array", 26);
			_opsDict.Add("create_fixed", 27);
		}
		private string[] _ids = {"IDL:CORBA/Repository:1.0","IDL:CORBA/Container:1.0"};

		[IdlName("def_kind")]
		public abstract CORBA.DefinitionKind DefKind 
		{
			get;
		}
		[IdlName("destroy")]
		public abstract void Destroy();
		[IdlName("lookup")]
		public abstract CORBA.IContained Lookup([WideChar(false)] string searchName);
		[IdlName("contents")]
		public abstract CORBA.IContained[] Contents(CORBA.DefinitionKind limitType, bool excludeInherited);
		[IdlName("lookup_name")]
		public abstract CORBA.IContained[] LookupName([WideChar(false)] string searchName, int levelsToSearch, CORBA.DefinitionKind limitType, bool excludeInherited);
		[IdlName("describe_contents")]
		public abstract CORBA.Container.Description[] DescribeContents(CORBA.DefinitionKind limitType, bool excludeInherited, int maxReturnedObjs);
		[IdlName("create_module")]
		public abstract CORBA.IModuleDef CreateModule([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version);
		[IdlName("create_constant")]
		public abstract CORBA.IConstantDef CreateConstant([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType type, CORBA.Any value);
		[IdlName("create_struct")]
		public abstract CORBA.IStructDef CreateStruct([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.StructMember[] members);
		[IdlName("create_union")]
		public abstract CORBA.IUnionDef CreateUnion([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType discriminatorType, CORBA.UnionMember[] members);
		[IdlName("create_enum")]
		public abstract CORBA.IEnumDef CreateEnum([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, string[] members);
		[IdlName("create_alias")]
		public abstract CORBA.IAliasDef CreateAlias([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType originalType);
		[IdlName("create_interface")]
		public abstract CORBA.IInterfaceDef CreateInterface([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IInterfaceDef[] baseInterfaces, bool isAbstract);
		[IdlName("create_value")]
		public abstract CORBA.IValueDef CreateValue([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, bool isCustom, bool isAbstract, CORBA.IValueDef baseValue, bool isTruncatable, CORBA.IValueDef[] abstractBaseValues, CORBA.IInterfaceDef[] supportedInterfaces, CORBA.Initializer[] initializers);
		[IdlName("create_value_box")]
		public abstract CORBA.IValueBoxDef CreateValueBox([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IIDLType originalTypeDef);
		[IdlName("create_exception")]
		public abstract CORBA.IExceptionDef CreateException([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.StructMember[] members);
		[IdlName("create_native")]
		public abstract CORBA.INativeDef CreateNative([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version);
		[IdlName("create_abstract_interface")]
		public abstract CORBA.IAbstractInterfaceDef CreateAbstractInterface([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IAbstractInterfaceDef[] baseInterfaces);
		[IdlName("create_local_interface")]
		public abstract CORBA.ILocalInterfaceDef CreateLocalInterface([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, CORBA.IInterfaceDef[] baseInterfaces);
		[IdlName("create_ext_value")]
		public abstract CORBA.IExtValueDef CreateExtValue([WideChar(false)] string id, [WideChar(false)] string name, [WideChar(false)] string version, bool isCustom, bool isAbstract, CORBA.IValueDef baseValue, bool isTruncatable, CORBA.IValueDef[] abstractBaseValues, CORBA.IInterfaceDef[] supportedInterfaces, CORBA.ExtInitializer[] initializers);
		[IdlName("lookup_id")]
		public abstract CORBA.IContained LookupId([WideChar(false)] string searchId);
		[IdlName("get_canonical_typecode")]
		public abstract CORBA.TypeCode GetCanonicalTypecode(CORBA.TypeCode tc);
		[IdlName("get_primitive")]
		public abstract CORBA.IPrimitiveDef GetPrimitive(CORBA.PrimitiveKind kind);
		[IdlName("create_string")]
		public abstract CORBA.IStringDef CreateString(uint bound);
		[IdlName("create_wstring")]
		public abstract CORBA.IWstringDef CreateWstring(uint bound);
		[IdlName("create_sequence")]
		public abstract CORBA.ISequenceDef CreateSequence(uint bound, CORBA.IIDLType elementType);
		[IdlName("create_array")]
		public abstract CORBA.IArrayDef CreateArray(uint length, CORBA.IIDLType elementType);
		[IdlName("create_fixed")]
		public abstract CORBA.IFixedDef CreateFixed(ushort digits, short scale);

		public override string[] _AllInterfaces(PortableServer.IPOA poa, byte[] objId)
		{
			return _ids;
		}

		public virtual CORBA.IRepository _This()
		{
			return CORBA.RepositoryHelper.Narrow(_ThisObject());
		}

		public virtual CORBA.IRepository _This(CORBA.ORB orb)
		{
			return CORBA.RepositoryHelper.Narrow(_ThisObject(orb));
		}

		public CORBA.IOutputStream _Invoke(string method, CORBA.IInputStream inputStream, CORBA.IResponseHandler handler)
		{
			CORBA.IOutputStream outputStream = null;
			int opIndex;
			if (_opsDict.TryGetValue(method, out opIndex))
			{
				switch (opIndex)
				{
					case 0:
					{
							outputStream = handler.CreateReply();
							CORBA.DefinitionKindHelper.Write(outputStream, DefKind);
					}
					break;
					case 1:
					{
							outputStream = handler.CreateReply();
							Destroy();
					}
					break;
					case 2:
					{
							string searchName;
							searchName = inputStream.ReadString();
							outputStream = handler.CreateReply();
							var _result = Lookup(searchName);
							CORBA.ContainedHelper.Write(outputStream, _result);
					}
					break;
					case 3:
					{
							CORBA.DefinitionKind limitType;
							limitType = CORBA.DefinitionKindHelper.Read(inputStream);
							bool excludeInherited;
							excludeInherited = inputStream.ReadBoolean();
							outputStream = handler.CreateReply();
							var _result = Contents(limitType, excludeInherited);
							{
								outputStream.WriteLong(_result.Length);
								for (int i0 = 0; i0 < _result.Length; i0++)
								{
									CORBA.ContainedHelper.Write(outputStream, _result[i0]);
								}
							}
					}
					break;
					case 4:
					{
							string searchName;
							searchName = inputStream.ReadString();
							int levelsToSearch;
							levelsToSearch = inputStream.ReadLong();
							CORBA.DefinitionKind limitType;
							limitType = CORBA.DefinitionKindHelper.Read(inputStream);
							bool excludeInherited;
							excludeInherited = inputStream.ReadBoolean();
							outputStream = handler.CreateReply();
							var _result = LookupName(searchName, levelsToSearch, limitType, excludeInherited);
							{
								outputStream.WriteLong(_result.Length);
								for (int i0 = 0; i0 < _result.Length; i0++)
								{
									CORBA.ContainedHelper.Write(outputStream, _result[i0]);
								}
							}
					}
					break;
					case 5:
					{
							CORBA.DefinitionKind limitType;
							limitType = CORBA.DefinitionKindHelper.Read(inputStream);
							bool excludeInherited;
							excludeInherited = inputStream.ReadBoolean();
							int maxReturnedObjs;
							maxReturnedObjs = inputStream.ReadLong();
							outputStream = handler.CreateReply();
							var _result = DescribeContents(limitType, excludeInherited, maxReturnedObjs);
							{
								outputStream.WriteLong(_result.Length);
								for (int i0 = 0; i0 < _result.Length; i0++)
								{
									CORBA.Container.DescriptionHelper.Write(outputStream, _result[i0]);
								}
							}
					}
					break;
					case 6:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							outputStream = handler.CreateReply();
							var _result = CreateModule(id, name, version);
							CORBA.ModuleDefHelper.Write(outputStream, _result);
					}
					break;
					case 7:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.IIDLType type;
							type = CORBA.IDLTypeHelper.Read(inputStream);
							CORBA.Any value;
							value = inputStream.ReadAny();
							outputStream = handler.CreateReply();
							var _result = CreateConstant(id, name, version, type, value);
							CORBA.ConstantDefHelper.Write(outputStream, _result);
					}
					break;
					case 8:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.StructMember[] members;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								members = new CORBA.StructMember[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.StructMember _item0;
									_item0 = CORBA.StructMemberHelper.Read(inputStream);
									members[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateStruct(id, name, version, members);
							CORBA.StructDefHelper.Write(outputStream, _result);
					}
					break;
					case 9:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.IIDLType discriminatorType;
							discriminatorType = CORBA.IDLTypeHelper.Read(inputStream);
							CORBA.UnionMember[] members;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								members = new CORBA.UnionMember[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.UnionMember _item0;
									_item0 = CORBA.UnionMemberHelper.Read(inputStream);
									members[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateUnion(id, name, version, discriminatorType, members);
							CORBA.UnionDefHelper.Write(outputStream, _result);
					}
					break;
					case 10:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							string[] members;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								members = new string[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									string _item0;
									_item0 = inputStream.ReadString();
									members[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateEnum(id, name, version, members);
							CORBA.EnumDefHelper.Write(outputStream, _result);
					}
					break;
					case 11:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.IIDLType originalType;
							originalType = CORBA.IDLTypeHelper.Read(inputStream);
							outputStream = handler.CreateReply();
							var _result = CreateAlias(id, name, version, originalType);
							CORBA.AliasDefHelper.Write(outputStream, _result);
					}
					break;
					case 12:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.IInterfaceDef[] baseInterfaces;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								baseInterfaces = new CORBA.IInterfaceDef[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.IInterfaceDef _item0;
									_item0 = CORBA.InterfaceDefHelper.Read(inputStream);
									baseInterfaces[i0] = _item0;
								}
							}
							bool isAbstract;
							isAbstract = inputStream.ReadBoolean();
							outputStream = handler.CreateReply();
							var _result = CreateInterface(id, name, version, baseInterfaces, isAbstract);
							CORBA.InterfaceDefHelper.Write(outputStream, _result);
					}
					break;
					case 13:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							bool isCustom;
							isCustom = inputStream.ReadBoolean();
							bool isAbstract;
							isAbstract = inputStream.ReadBoolean();
							CORBA.IValueDef baseValue;
							baseValue = CORBA.ValueDefHelper.Read(inputStream);
							bool isTruncatable;
							isTruncatable = inputStream.ReadBoolean();
							CORBA.IValueDef[] abstractBaseValues;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								abstractBaseValues = new CORBA.IValueDef[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.IValueDef _item0;
									_item0 = CORBA.ValueDefHelper.Read(inputStream);
									abstractBaseValues[i0] = _item0;
								}
							}
							CORBA.IInterfaceDef[] supportedInterfaces;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								supportedInterfaces = new CORBA.IInterfaceDef[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.IInterfaceDef _item0;
									_item0 = CORBA.InterfaceDefHelper.Read(inputStream);
									supportedInterfaces[i0] = _item0;
								}
							}
							CORBA.Initializer[] initializers;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								initializers = new CORBA.Initializer[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.Initializer _item0;
									_item0 = CORBA.InitializerHelper.Read(inputStream);
									initializers[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateValue(id, name, version, isCustom, isAbstract, baseValue, isTruncatable, abstractBaseValues, supportedInterfaces, initializers);
							CORBA.ValueDefHelper.Write(outputStream, _result);
					}
					break;
					case 14:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.IIDLType originalTypeDef;
							originalTypeDef = CORBA.IDLTypeHelper.Read(inputStream);
							outputStream = handler.CreateReply();
							var _result = CreateValueBox(id, name, version, originalTypeDef);
							CORBA.ValueBoxDefHelper.Write(outputStream, _result);
					}
					break;
					case 15:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.StructMember[] members;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								members = new CORBA.StructMember[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.StructMember _item0;
									_item0 = CORBA.StructMemberHelper.Read(inputStream);
									members[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateException(id, name, version, members);
							CORBA.ExceptionDefHelper.Write(outputStream, _result);
					}
					break;
					case 16:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							outputStream = handler.CreateReply();
							var _result = CreateNative(id, name, version);
							CORBA.NativeDefHelper.Write(outputStream, _result);
					}
					break;
					case 17:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.IAbstractInterfaceDef[] baseInterfaces;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								baseInterfaces = new CORBA.IAbstractInterfaceDef[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.IAbstractInterfaceDef _item0;
									_item0 = CORBA.AbstractInterfaceDefHelper.Read(inputStream);
									baseInterfaces[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateAbstractInterface(id, name, version, baseInterfaces);
							CORBA.AbstractInterfaceDefHelper.Write(outputStream, _result);
					}
					break;
					case 18:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							CORBA.IInterfaceDef[] baseInterfaces;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								baseInterfaces = new CORBA.IInterfaceDef[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.IInterfaceDef _item0;
									_item0 = CORBA.InterfaceDefHelper.Read(inputStream);
									baseInterfaces[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateLocalInterface(id, name, version, baseInterfaces);
							CORBA.LocalInterfaceDefHelper.Write(outputStream, _result);
					}
					break;
					case 19:
					{
							string id;
							id = inputStream.ReadString();
							string name;
							name = inputStream.ReadString();
							string version;
							version = inputStream.ReadString();
							bool isCustom;
							isCustom = inputStream.ReadBoolean();
							bool isAbstract;
							isAbstract = inputStream.ReadBoolean();
							CORBA.IValueDef baseValue;
							baseValue = CORBA.ValueDefHelper.Read(inputStream);
							bool isTruncatable;
							isTruncatable = inputStream.ReadBoolean();
							CORBA.IValueDef[] abstractBaseValues;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								abstractBaseValues = new CORBA.IValueDef[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.IValueDef _item0;
									_item0 = CORBA.ValueDefHelper.Read(inputStream);
									abstractBaseValues[i0] = _item0;
								}
							}
							CORBA.IInterfaceDef[] supportedInterfaces;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								supportedInterfaces = new CORBA.IInterfaceDef[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.IInterfaceDef _item0;
									_item0 = CORBA.InterfaceDefHelper.Read(inputStream);
									supportedInterfaces[i0] = _item0;
								}
							}
							CORBA.ExtInitializer[] initializers;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								initializers = new CORBA.ExtInitializer[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									CORBA.ExtInitializer _item0;
									_item0 = CORBA.ExtInitializerHelper.Read(inputStream);
									initializers[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							var _result = CreateExtValue(id, name, version, isCustom, isAbstract, baseValue, isTruncatable, abstractBaseValues, supportedInterfaces, initializers);
							CORBA.ExtValueDefHelper.Write(outputStream, _result);
					}
					break;
					case 20:
					{
							string searchId;
							searchId = inputStream.ReadString();
							outputStream = handler.CreateReply();
							var _result = LookupId(searchId);
							CORBA.ContainedHelper.Write(outputStream, _result);
					}
					break;
					case 21:
					{
							CORBA.TypeCode tc;
							tc = inputStream.ReadTypeCode();
							outputStream = handler.CreateReply();
							var _result = GetCanonicalTypecode(tc);
							outputStream.WriteTypeCode(_result);
					}
					break;
					case 22:
					{
							CORBA.PrimitiveKind kind;
							kind = CORBA.PrimitiveKindHelper.Read(inputStream);
							outputStream = handler.CreateReply();
							var _result = GetPrimitive(kind);
							CORBA.PrimitiveDefHelper.Write(outputStream, _result);
					}
					break;
					case 23:
					{
							uint bound;
							bound = inputStream.ReadULong();
							outputStream = handler.CreateReply();
							var _result = CreateString(bound);
							CORBA.StringDefHelper.Write(outputStream, _result);
					}
					break;
					case 24:
					{
							uint bound;
							bound = inputStream.ReadULong();
							outputStream = handler.CreateReply();
							var _result = CreateWstring(bound);
							CORBA.WstringDefHelper.Write(outputStream, _result);
					}
					break;
					case 25:
					{
							uint bound;
							bound = inputStream.ReadULong();
							CORBA.IIDLType elementType;
							elementType = CORBA.IDLTypeHelper.Read(inputStream);
							outputStream = handler.CreateReply();
							var _result = CreateSequence(bound, elementType);
							CORBA.SequenceDefHelper.Write(outputStream, _result);
					}
					break;
					case 26:
					{
							uint length;
							length = inputStream.ReadULong();
							CORBA.IIDLType elementType;
							elementType = CORBA.IDLTypeHelper.Read(inputStream);
							outputStream = handler.CreateReply();
							var _result = CreateArray(length, elementType);
							CORBA.ArrayDefHelper.Write(outputStream, _result);
					}
					break;
					case 27:
					{
							ushort digits;
							digits = inputStream.ReadUShort();
							short scale;
							scale = inputStream.ReadShort();
							outputStream = handler.CreateReply();
							var _result = CreateFixed(digits, scale);
							CORBA.FixedDefHelper.Write(outputStream, _result);
					}
					break;
				}
				return outputStream;
			}
			else
			{
				throw new CORBA.BadOperation(method + " not found");
			}
		}
	}
}
