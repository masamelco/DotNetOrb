/**
 * Generated by DotNetORb.IdlCompiler V 1.0.0.0
 * Timestamp: 25/02/2024 9:49:38
 *
 */

using System;
using System.Collections.Generic;
using System.Linq;
using CORBA;


namespace ImplementationRepository
{

	public abstract class AdministrationExtPOA: PortableServer.Servant, CORBA.IInvokeHandler, IAdministrationExtOperations
	{
		static private Dictionary<string,int> _opsDict = new Dictionary<string,int>();
		static AdministrationExtPOA()
		{
			_opsDict.Add("activate_server", 0);
			_opsDict.Add("add_or_update_server", 1);
			_opsDict.Add("remove_server", 2);
			_opsDict.Add("shutdown_server", 3);
			_opsDict.Add("server_is_running", 4);
			_opsDict.Add("server_is_shutting_down", 5);
			_opsDict.Add("find", 6);
			_opsDict.Add("list", 7);
			_opsDict.Add("shutdown", 8);
			_opsDict.Add("link_servers", 9);
			_opsDict.Add("kill_server", 10);
			_opsDict.Add("force_remove_server", 11);
		}
		private string[] _ids = {"IDL:ImplementationRepository/AdministrationExt:1.0","IDL:ImplementationRepository/Administration:1.0"};

		[IdlName("activate_server")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		[ThrowsIdlException(typeof(ImplementationRepository.CannotActivate))]
		public abstract void ActivateServer([WideChar(false)] string server);
		[IdlName("add_or_update_server")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		public abstract void AddOrUpdateServer([WideChar(false)] string server, ImplementationRepository.StartupOptions options);
		[IdlName("remove_server")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		public abstract void RemoveServer([WideChar(false)] string server);
		[IdlName("shutdown_server")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		public abstract void ShutdownServer([WideChar(false)] string server);
		[IdlName("server_is_running")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		public abstract void ServerIsRunning([WideChar(false)] string server, [WideChar(false)] string partialIor, ImplementationRepository.IServerObject serverObject);
		[IdlName("server_is_shutting_down")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		public abstract void ServerIsShuttingDown([WideChar(false)] string server);
		[IdlName("find")]
		public abstract void Find([WideChar(false)] string server, out ImplementationRepository.ServerInformation info);
		[IdlName("list")]
		public abstract void List(uint howMany, bool determineActiveStatus, out ImplementationRepository.ServerInformation[] serverList, out ImplementationRepository.IServerInformationIterator serverIterator);
		[IdlName("shutdown")]
		public abstract void Shutdown(bool activators, bool servers);
		[IdlName("link_servers")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		[ThrowsIdlException(typeof(ImplementationRepository.CannotComplete))]
		public abstract void LinkServers([WideChar(false)] string server, string[] peers);
		[IdlName("kill_server")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		[ThrowsIdlException(typeof(ImplementationRepository.CannotComplete))]
		public abstract void KillServer([WideChar(false)] string server, short signum);
		[IdlName("force_remove_server")]
		[ThrowsIdlException(typeof(ImplementationRepository.NotFound))]
		[ThrowsIdlException(typeof(ImplementationRepository.CannotComplete))]
		public abstract void ForceRemoveServer([WideChar(false)] string server, short signum);

		public override string[] _AllInterfaces(PortableServer.IPOA poa, byte[] objId)
		{
			return _ids;
		}

		public virtual ImplementationRepository.IAdministrationExt _This()
		{
			return ImplementationRepository.AdministrationExtHelper.Narrow(_ThisObject());
		}

		public virtual ImplementationRepository.IAdministrationExt _This(CORBA.ORB orb)
		{
			return ImplementationRepository.AdministrationExtHelper.Narrow(_ThisObject(orb));
		}

		public CORBA.IOutputStream _Invoke(string method, CORBA.IInputStream inputStream, CORBA.IResponseHandler handler)
		{
			CORBA.IOutputStream outputStream = null;
			int opIndex;
			if (_opsDict.TryGetValue(method, out opIndex))
			{
				switch (opIndex)
				{
					case 0:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							outputStream = handler.CreateReply();
							ActivateServer(server);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
						catch(ImplementationRepository.CannotActivate ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.CannotActivateHelper.Write(outputStream, ex);
						}
					}
					break;
					case 1:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							ImplementationRepository.StartupOptions options;
							options = ImplementationRepository.StartupOptionsHelper.Read(inputStream);
							outputStream = handler.CreateReply();
							AddOrUpdateServer(server,options);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
					}
					break;
					case 2:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							outputStream = handler.CreateReply();
							RemoveServer(server);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
					}
					break;
					case 3:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							outputStream = handler.CreateReply();
							ShutdownServer(server);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
					}
					break;
					case 4:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							string partialIor;
							partialIor = inputStream.ReadString();
							ImplementationRepository.IServerObject serverObject;
							serverObject = ImplementationRepository.ServerObjectHelper.Read(inputStream);
							outputStream = handler.CreateReply();
							ServerIsRunning(server,partialIor,serverObject);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
					}
					break;
					case 5:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							outputStream = handler.CreateReply();
							ServerIsShuttingDown(server);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
					}
					break;
					case 6:
					{
							string server;
							server = inputStream.ReadString();
							outputStream = handler.CreateReply();
							Find(server,out ImplementationRepository.ServerInformation info);
							ImplementationRepository.ServerInformationHelper.Write(outputStream, info);
					}
					break;
					case 7:
					{
							uint howMany;
							howMany = inputStream.ReadULong();
							bool determineActiveStatus;
							determineActiveStatus = inputStream.ReadBoolean();
							outputStream = handler.CreateReply();
							List(howMany,determineActiveStatus,out ImplementationRepository.ServerInformation[] serverList,out ImplementationRepository.IServerInformationIterator serverIterator);
							{
								outputStream.WriteLong(serverList.Length);
								for (int i0 = 0; i0 < serverList.Length; i0++)
								{
									ImplementationRepository.ServerInformationHelper.Write(outputStream, serverList[i0]);
								}
							}
							ImplementationRepository.ServerInformationIteratorHelper.Write(outputStream, serverIterator);
					}
					break;
					case 8:
					{
							bool activators;
							activators = inputStream.ReadBoolean();
							bool servers;
							servers = inputStream.ReadBoolean();
							outputStream = handler.CreateReply();
							Shutdown(activators,servers);
					}
					break;
					case 9:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							string[] peers;
							{
								var _capacity0 = inputStream.ReadLong();
								if (inputStream.Available > 0 && _capacity0 > inputStream.Available)
								{
									throw new Marshal($"Sequence length too large. Only {inputStream.Available} and trying to assign {_capacity0}");
								}
								peers = new string[_capacity0];
								for (int i0 = 0; i0 < _capacity0; i0++)
								{
									string _item0;
									_item0 = inputStream.ReadString();
									peers[i0] = _item0;
								}
							}
							outputStream = handler.CreateReply();
							LinkServers(server,peers);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
						catch(ImplementationRepository.CannotComplete ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.CannotCompleteHelper.Write(outputStream, ex);
						}
					}
					break;
					case 10:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							short signum;
							signum = inputStream.ReadShort();
							outputStream = handler.CreateReply();
							KillServer(server,signum);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
						catch(ImplementationRepository.CannotComplete ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.CannotCompleteHelper.Write(outputStream, ex);
						}
					}
					break;
					case 11:
					{
						try
						{
							string server;
							server = inputStream.ReadString();
							short signum;
							signum = inputStream.ReadShort();
							outputStream = handler.CreateReply();
							ForceRemoveServer(server,signum);
						}
						catch(ImplementationRepository.NotFound ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.NotFoundHelper.Write(outputStream, ex);
						}
						catch(ImplementationRepository.CannotComplete ex)
						{
							outputStream = handler.CreateExceptionReply();
							ImplementationRepository.CannotCompleteHelper.Write(outputStream, ex);
						}
					}
					break;
				}
				return outputStream;
			}
			else
			{
				throw new CORBA.BadOperation(method + " not found");
			}
		}
	}
}
